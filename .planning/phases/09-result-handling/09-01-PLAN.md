---
phase: 09-result-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [get-shit-done/workflows/execute-phase.md]
autonomous: true

must_haves:
  truths:
    - "Orchestrator parses specialist output regardless of format variations"
    - "Orchestrator extracts task status (success/failure) from specialist results"
    - "Orchestrator handles classifyHandoffIfNeeded error as non-fatal"
  artifacts:
    - path: "get-shit-done/workflows/execute-phase.md"
      provides: "parse_specialist_result() function with three-tier parsing"
      contains: "parse_specialist_result"
    - path: "get-shit-done/workflows/execute-phase.md"
      provides: "Fallback verification for actual outputs"
      contains: "Check if specialist created expected outputs"
  key_links:
    - from: "Task() result"
      to: "parse_specialist_result()"
      via: "function call after specialist returns"
      pattern: "parse_specialist_result.*RESULT"
    - from: "parse_specialist_result()"
      to: "Status determination"
      via: "Three-tier parsing logic"
      pattern: "echo.*SUCCESS|FAILURE"
---

<objective>
Implement multi-layer result parsing for specialist outputs with robust fallback strategies.

Purpose: Enable orchestrator to reliably extract execution status and metadata from specialist returns regardless of format variations.
Output: parse_specialist_result() function with three-tier parsing (structured, patterns, verification)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-result-handling/09-RESEARCH.md
@.planning/phases/08-escape-hatch-protocol/08-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parse_specialist_result function</name>
  <files>get-shit-done/workflows/execute-phase.md</files>
  <action>
    Create parse_specialist_result() function after the validate_specialist() function (around line 213).

    Function should implement three-tier parsing:
    1. Tier 1: Try structured format (## TASK COMPLETE, ## FAILED)
    2. Tier 2: Try common patterns (Task.*completed successfully, error messages)
    3. Tier 3: Verification fallback (check for expected outputs)

    Based on research pattern from lines 169-199 of 09-RESEARCH.md:
    ```bash
    parse_specialist_result() {
      local RESULT="$1"
      local TASK_NUM="$2"
      local SPECIALIST="$3"
      local PLAN_DIR="$4"
      local PHASE="$5"
      local PLAN="$6"

      # Tier 1: Structured format
      # Check for ## TASK COMPLETE, ## COMPLETE, ## DONE markers

      # Tier 2: Common patterns
      # Check for "Task.*completed", "Successfully", "Error:", "Failed:"

      # Tier 3: Verification fallback
      # Check if SUMMARY.md exists
      # Check if expected files were created
      # Check if commits were made
    }
    ```

    Include handling for classifyHandoffIfNeeded error (known Claude Code bug) - treat as non-fatal, proceed to verification.
  </action>
  <verify>grep -A 50 "parse_specialist_result()" get-shit-done/workflows/execute-phase.md</verify>
  <done>Function exists with three-tier parsing logic, returns SUCCESS or FAILURE</done>
</task>

<task type="auto">
  <name>Task 2: Integrate parser with specialist execution</name>
  <files>get-shit-done/workflows/execute-phase.md</files>
  <action>
    Integrate parse_specialist_result() into the specialist spawning flow (after Task() calls).

    After each Task() execution (around lines 257-297 and verification section around lines 477-502):
    1. Capture the result into a variable
    2. Call parse_specialist_result() to determine status
    3. Log the parsing outcome
    4. Store raw output in XX-YY-RESULT.txt for debugging (optional but recommended)

    Pattern:
    ```bash
    # Execute specialist
    SPECIALIST_RESULT=$(Task(
      subagent_type="${CURRENT_SPECIALIST}",
      ...
    ))

    # Parse result
    TASK_STATUS=$(parse_specialist_result "$SPECIALIST_RESULT" "$TASK_NUM" "$CURRENT_SPECIALIST" "$PHASE_DIR" "$PHASE" "$PLAN")

    # Log outcome
    echo "Task $TASK_NUM executed by $CURRENT_SPECIALIST: $TASK_STATUS"

    # Optional: Store raw output for debugging
    echo "$SPECIALIST_RESULT" > "${PHASE_DIR}/${PHASE}-${PLAN}-task${TASK_NUM}-RESULT.txt"

    # Handle failure
    if [ "$TASK_STATUS" = "FAILURE" ]; then
      echo "Task $TASK_NUM failed, checking fallback options..."
      # Existing failure handling logic
    fi
    ```

    Also integrate with verification specialist parsing (already has basic parsing, enhance with function).
  </action>
  <verify>grep -B 2 -A 5 "parse_specialist_result" get-shit-done/workflows/execute-phase.md | head -30</verify>
  <done>Parser integrated after Task() calls, status captured and logged</done>
</task>

<task type="auto">
  <name>Task 3: Add fallback verification checks</name>
  <files>get-shit-done/workflows/execute-phase.md</files>
  <action>
    Enhance the parse_specialist_result() function's Tier 3 verification fallback.

    Add comprehensive checks for actual work completed:
    1. Check if SUMMARY.md was created in phase directory
    2. Check if key files from task exist on disk (parse from PLAN.md or SUMMARY.md)
    3. Check git log for commits with phase-plan pattern
    4. Check for specific markers in output (file paths, commit hashes)

    Implementation in Tier 3 section:
    ```bash
    # Tier 3: Verification fallback
    echo "DEBUG: Falling back to output verification" >&2

    # Check if SUMMARY.md exists
    if [ -f "${PLAN_DIR}/${PHASE}-${PLAN}-SUMMARY.md" ]; then
      echo "DEBUG: Found SUMMARY.md, task likely succeeded" >&2
      echo "SUCCESS"
      return
    fi

    # Check for recent commits
    RECENT_COMMITS=$(git log --oneline --all --grep="${PHASE}-${PLAN}" --since="5 minutes ago" 2>/dev/null | wc -l)
    if [ "$RECENT_COMMITS" -gt 0 ]; then
      echo "DEBUG: Found $RECENT_COMMITS recent commits, task likely succeeded" >&2
      echo "SUCCESS"
      return
    fi

    # Check for file creation patterns in output
    if echo "$RESULT" | grep -q "created.*\.md\|wrote.*\.ts\|modified.*\.js"; then
      echo "DEBUG: Found file creation patterns, task likely succeeded" >&2
      echo "SUCCESS"
      return
    fi

    # Default to failure if no evidence of success
    echo "DEBUG: No evidence of success found" >&2
    echo "FAILURE"
    ```

    This makes the parser resilient to format variations and Claude Code bugs.
  </action>
  <verify>grep -A 20 "Tier 3: Verification fallback" get-shit-done/workflows/execute-phase.md</verify>
  <done>Tier 3 fallback includes SUMMARY check, git log check, and output pattern check</done>
</task>

</tasks>

<verification>
- parse_specialist_result() function exists with three tiers
- Function integrated after Task() calls
- Tier 3 includes comprehensive fallback checks
- Raw output saved for debugging
- classifyHandoffIfNeeded error handled as non-fatal
</verification>

<success_criteria>
- Orchestrator parses all specialist output formats successfully
- Three-tier parsing provides robust fallback
- False failures from Claude Code bugs eliminated
- Raw output preserved for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/09-result-handling/09-01-SUMMARY.md`
</output>