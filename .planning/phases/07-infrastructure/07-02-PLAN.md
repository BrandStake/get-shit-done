---
phase: 07-infrastructure
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - .claude/get-shit-done/workflows/plan-phase.md
  - .claude/agents/gsd-planner.md
autonomous: true
requirements: [PLAN-01, PLAN-02, PLAN-03, PLAN-04, PLAN-05]

must_haves:
  truths:
    - "plan-phase orchestrator generates available_agents.md before spawning planner"
    - "gsd-planner reads available_agents.md as context"
    - "gsd-planner detects task domains using keyword patterns"
    - "gsd-planner assigns specialist field to tasks based on domain match"
    - "Tasks without domain match get specialist: null for direct execution"
    - "Planner validates specialist exists before assignment"
  artifacts:
    - path: ".claude/get-shit-done/workflows/plan-phase.md"
      provides: "Agent enumeration before planner spawn"
      contains: "agents enumerate"
    - path: ".claude/agents/gsd-planner.md"
      provides: "Specialist assignment logic in planning workflow"
      contains: "specialist field"
      min_lines: 20
    - path: ".planning/phases/XX-name/XX-NN-PLAN.md"
      provides: "Tasks with specialist frontmatter field"
      contains: "specialist:"
  key_links:
    - from: ".claude/get-shit-done/workflows/plan-phase.md"
      to: "gsd-tools.cjs agents enumerate"
      via: "Bash command before Task() spawn"
      pattern: "agents enumerate.*before.*Task"
    - from: ".claude/agents/gsd-planner.md"
      to: ".planning/available_agents.md"
      via: "files_to_read in plan-phase spawn"
      pattern: "files_to_read.*available_agents"
    - from: "gsd-planner.md task assignment"
      to: "PLAN.md frontmatter"
      via: "specialist field in tasks array"
      pattern: "specialist:.*python-pro"
---

<objective>
Integrate agent discovery into planning workflow enabling planner to assign specialists to tasks based on domain detection and specialist availability.

Purpose: Move delegation routing from execution time to planning time. Planner sees available specialists, detects task domains, assigns specialist field to tasks, validates availability before assignment. This prevents spawn failures and enables informed routing decisions.

Output: Updated plan-phase orchestrator generating agent roster before planning, updated gsd-planner assigning specialist field to tasks based on domain detection.
</objective>

<execution_context>
@/Users/matte/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-infrastructure/07-RESEARCH.md
@.planning/phases/07-infrastructure/07-01-SUMMARY.md
@.claude/get-shit-done/workflows/plan-phase.md
@.claude/agents/gsd-planner.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update plan-phase orchestrator with agent enumeration</name>
  <files>
    .claude/get-shit-done/workflows/plan-phase.md
  </files>
  <action>
Update plan-phase.md orchestrator to generate agent roster before spawning planner.

**Add to load_project_state step (after init call):**
```bash
# Generate fresh agent roster for planner context
node "${GSD_TOOLS}" agents enumerate --output .planning/available_agents.md
```

**Update spawn_planner step:**

Modify Task() call to include available_agents.md in files_to_read:

```bash
Task(
  subagent_type="gsd-planner",
  model="${PLANNER_MODEL}",
  prompt="
<planning_context>
**Phase:** ${PHASE_NUM}
**Mode:** standard

<files_to_read>
- .planning/STATE.md (Project State)
- .planning/ROADMAP.md (Roadmap)
- .planning/REQUIREMENTS.md (Requirements)
- .planning/available_agents.md (Available Specialists)
- .planning/phases/${PHASE_DIR}/${PHASE_NUM}-RESEARCH.md (Technical Research)
</files_to_read>

**Phase requirement IDs:** ${REQUIREMENT_IDS}

**Project instructions:** Read ./CLAUDE.md if exists
**Project skills:** Check .agents/skills/ directory
</planning_context>

Create PLAN.md files with specialist assignments.
Tasks should have 'specialist' field in frontmatter based on domain detection.
Tasks without domain match get 'specialist: null' for direct gsd-executor execution.
Validate specialist exists in available_agents.md before assignment.
",
  description="Planning phase ${PHASE_NUM} with specialist support"
)
```

**Location in plan-phase.md:**
- Agent enumeration in load_project_state step (early in workflow)
- Updated Task() spawn in spawn_planner step
- Add note in orchestrator context section about specialist support

**Error handling:**
- If agents enumerate fails, log warning but continue (planner works without specialists)
- If available_agents.md empty, planner assigns specialist: null to all tasks

**Follow orchestrator patterns:**
- Use ${GSD_TOOLS} variable for gsd-tools.cjs path
- Structured step tags: `<step name="...">`
- Error handling subsections
  </action>
  <verify>
    <automated>
cd /Users/matte/Documents/workspace/get-shit-done && \
grep -q "agents enumerate" .claude/get-shit-done/workflows/plan-phase.md && \
grep -q "available_agents.md" .claude/get-shit-done/workflows/plan-phase.md && \
grep -A 10 "files_to_read" .claude/get-shit-done/workflows/plan-phase.md | grep -q "available_agents.md"
    </automated>
    <manual>
Verify plan-phase.md contains:
1. Agent enumeration call in load_project_state step
2. available_agents.md in Task() files_to_read parameter
3. Instructions about specialist assignment in planner prompt
4. Error handling for enumeration failures
    </manual>
    <sampling_rate>run after task commits</sampling_rate>
  </verify>
  <done>
plan-phase.md orchestrator generates available_agents.md before spawning planner, includes agent roster in planner context via files_to_read, provides specialist assignment instructions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add specialist assignment logic to gsd-planner</name>
  <files>
    .claude/agents/gsd-planner.md
  </files>
  <action>
Update gsd-planner.md to assign specialist field to tasks based on domain detection and specialist availability.

**Add new section after task_breakdown section:**

```markdown
<specialist_assignment>

## Assigning Specialists to Tasks

**When to assign:** After breaking phase into tasks, before grouping into plans.

**Process:**

1. **Load available specialists:**
   - Read .planning/available_agents.md (provided in files_to_read by orchestrator)
   - Parse specialist names from markdown list format: `- **specialist-name**: description`
   - Build roster array for validation

2. **Detect task domain:**
   - Apply keyword pattern matching to task action description
   - Language specialists: Python (python, fastapi, django), TypeScript (typescript, tsx, react), Go (golang, go module)
   - Infrastructure specialists: Kubernetes (kubernetes, k8s), Docker (docker, dockerfile)
   - Frontend specialists: React (react, jsx), Vue (vue.js, vuex)
   - Backend specialists: API (rest api, graphql), Database (postgres, mysql, mongodb)
   - Priority ordering: specific frameworks > generic languages > file extensions

3. **Validate specialist availability:**
   - If domain detected, check if matching specialist in roster
   - If specialist exists in available_agents.md, assign to task
   - If specialist NOT in roster, assign null (specialist unavailable or not installed)

4. **Assign to task frontmatter:**
   - Add specialist field to tasks array in PLAN.md frontmatter
   - Format: `specialist: python-pro` or `specialist: null`
   - Null-safe: specialist=null means direct gsd-executor execution

**Domain detection patterns (REUSE from v1.21):**

| Domain | Keywords | Specialist |
|--------|----------|------------|
| Python | python, fastapi, django, flask, pytest | python-pro |
| TypeScript | typescript, tsx, react, next.js | typescript-pro |
| Go | golang, go module, go.mod | golang-pro |
| Kubernetes | kubernetes, k8s, kubectl, helm | kubernetes-specialist |
| Docker | docker, dockerfile, container | docker-expert |
| React | react, jsx, component, hooks | react-specialist |
| API | rest api, graphql, endpoint | api-specialist |

**Fallback behavior:**
- Task with no domain match → specialist: null (direct execution)
- Task domain detected but specialist unavailable → specialist: null + warning in plan
- Checkpoint tasks → ALWAYS specialist: null (require GSD protocol knowledge)

**Example PLAN.md frontmatter:**

```yaml
---
phase: XX-name
plan: NN
type: execute
wave: 1
depends_on: []
files_modified: [src/api/users.py]
autonomous: true
requirements: [REQ-01]
must_haves:
  truths: []
  artifacts: []
  key_links: []
tasks:
  - specialist: python-pro  # FastAPI task, python-pro available
    name: Create FastAPI user endpoint
  - specialist: null  # Config task, no specialist match
    name: Update environment variables
---
```

</specialist_assignment>
```

**Update write_phase_prompt step:**

Add specialist field writing logic when creating PLAN.md files:
- After determining task breakdown, call specialist assignment
- Validate specialist against available_agents.md roster
- Write tasks array in frontmatter with specialist field
- Document specialist assignment rationale in plan if non-obvious

**Update validation step:**

Add specialist validation to frontmatter validation:
- Check specialist field exists in all tasks
- Warn if specialist assigned but not in available_agents.md
- Accept specialist: null as valid value

**Error handling:**
- If available_agents.md not in context, assign specialist: null to all tasks
- If domain detection fails, default to specialist: null (safe fallback)
- Log specialist assignment decisions for observability
  </action>
  <verify>
    <automated>
cd /Users/matte/Documents/workspace/get-shit-done && \
grep -q "specialist_assignment" .claude/agents/gsd-planner.md && \
grep -q "specialist:" .claude/agents/gsd-planner.md && \
grep -q "domain detection" .claude/agents/gsd-planner.md && \
grep -q "available_agents.md" .claude/agents/gsd-planner.md
    </automated>
    <manual>
Verify gsd-planner.md contains:
1. specialist_assignment section with process steps
2. Domain detection patterns table
3. Specialist validation against roster
4. Fallback behavior documented
5. Example PLAN.md frontmatter with specialist field
    </manual>
    <sampling_rate>run after task commits</sampling_rate>
  </verify>
  <done>
gsd-planner.md includes specialist assignment logic detecting task domains using keyword patterns, validating specialist availability against available_agents.md, assigning specialist field to tasks in PLAN.md frontmatter with null fallback.
  </done>
</task>

</tasks>

<verification>
End-to-end validation:

1. **Orchestrator integration:**
   ```bash
   grep -B 2 -A 2 "agents enumerate" .claude/get-shit-done/workflows/plan-phase.md
   # Verify: Called in load_project_state step before planner spawn
   ```

2. **Planner context:**
   ```bash
   grep -A 20 "files_to_read" .claude/get-shit-done/workflows/plan-phase.md | grep available_agents
   # Verify: available_agents.md included in planner context
   ```

3. **Specialist assignment:**
   ```bash
   grep -A 30 "specialist_assignment" .claude/agents/gsd-planner.md
   # Verify: Domain detection patterns, validation logic, frontmatter format
   ```

4. **Domain detection patterns:**
   ```bash
   grep -A 10 "Domain detection patterns" .claude/agents/gsd-planner.md
   # Verify: Reuses v1.21 patterns (Python, TypeScript, etc.)
   ```

5. **Null fallback:**
   ```bash
   grep "specialist: null" .claude/agents/gsd-planner.md
   # Verify: Documented fallback behavior for no match
   ```
</verification>

<success_criteria>
- [ ] plan-phase.md generates available_agents.md before spawning planner
- [ ] plan-phase.md includes available_agents.md in Task() files_to_read
- [ ] gsd-planner.md has specialist_assignment section with process
- [ ] gsd-planner.md has domain detection patterns table
- [ ] gsd-planner.md validates specialist against roster before assignment
- [ ] specialist field added to tasks in PLAN.md frontmatter format
- [ ] Null fallback documented for tasks without domain match
- [ ] All 5 PLAN requirements covered (PLAN-01 through PLAN-05)
</success_criteria>

<output>
After completion, create `.planning/phases/07-infrastructure/07-02-SUMMARY.md`
</output>
