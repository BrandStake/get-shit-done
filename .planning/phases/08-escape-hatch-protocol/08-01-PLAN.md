---
phase: 08-escape-hatch-protocol
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/workflows/execute-phase.md
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Orchestrator reads specialist field from each task in PLAN.md"
    - "Orchestrator spawns specialist when field is present and valid"
    - "Context is properly injected via files_to_read"
  artifacts:
    - path: "get-shit-done/workflows/execute-phase.md"
      provides: "Task-level specialist parsing and spawning"
      min_lines: 400
      exports: []
  key_links:
    - from: "execute-phase.md"
      to: "PLAN.md task specialist field"
      via: "awk/sed parsing"
      pattern: "specialist:"
    - from: "execute-phase.md"
      to: "Task() tool"
      via: "subagent_type parameter"
      pattern: "subagent_type.*SPECIALIST"
---

<objective>
Implement specialist field parsing and spawning logic in the execute-phase orchestrator.

Purpose: Enable the orchestrator to read specialist assignments from PLAN.md tasks and spawn the appropriate specialist agents via the Task tool.
Output: Modified execute-phase.md with per-task specialist parsing and spawning logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-escape-hatch-protocol/08-RESEARCH.md
@.planning/phases/07-infrastructure/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add task-level specialist parsing</name>
  <files>get-shit-done/workflows/execute-phase.md</files>
  <action>
    Modify the execute_waves step in execute-phase.md to parse specialist field from individual tasks in PLAN.md files:

    1. After loading the plan file, iterate through tasks to extract specialist assignments
    2. Use awk or sed to parse the specialist field from each task's frontmatter
    3. Store specialist assignments in an array indexed by task number
    4. Pattern to extract: `<task.*specialist:\s*([^>]+)`

    Implementation approach:
    - Parse ALL tasks at once when loading the plan
    - Build a SPECIALISTS array: SPECIALISTS[1]="python-pro", SPECIALISTS[2]="null", etc.
    - Use this array when spawning executors for each task

    Key patterns from research:
    ```bash
    # Extract all specialist fields from tasks in plan
    SPECIALISTS=()
    TASK_NUM=0
    while IFS= read -r line; do
      if [[ "$line" =~ ^specialist: ]]; then
        SPECIALIST=$(echo "$line" | sed 's/specialist:\s*//' | xargs)
        SPECIALISTS[$TASK_NUM]="$SPECIALIST"
      elif [[ "$line" =~ ^\<task ]]; then
        TASK_NUM=$((TASK_NUM + 1))
      fi
    done < "$PLAN_FILE"
    ```

    Place this parsing logic right after discovering the plan file but before spawning agents.
  </action>
  <verify>grep -A 10 "SPECIALISTS\[" get-shit-done/workflows/execute-phase.md</verify>
  <done>execute-phase.md contains task-level specialist parsing logic that builds SPECIALISTS array</done>
</task>

<task type="auto">
  <name>Task 2: Implement specialist spawning with context injection</name>
  <files>get-shit-done/workflows/execute-phase.md</files>
  <action>
    Extend the agent spawning section to use parsed specialist assignments:

    1. Modify the Task() spawning call to use the appropriate specialist for each task
    2. Pass specialist via subagent_type parameter
    3. Update the prompt to include task-specific context injection
    4. Ensure files_to_read block lists all necessary context files

    Key changes to Task() call:
    ```
    # Get specialist for current task/plan
    CURRENT_SPECIALIST="${SPECIALISTS[$TASK_NUM]:-gsd-executor}"

    Task(
      subagent_type="${CURRENT_SPECIALIST}",
      model="{executor_model}",
      prompt="
        <objective>
        Execute {task_specification} from plan {plan_number} of phase {phase_number}-{phase_name}.
        Specialist: ${CURRENT_SPECIALIST}
        </objective>

        <execution_context>
        @~/.claude/get-shit-done/workflows/execute-plan.md
        @~/.claude/get-shit-done/templates/summary.md
        </execution_context>

        <files_to_read>
        Read these files at execution start using the Read tool:
        - {phase_dir}/{plan_file} (Plan)
        - .planning/STATE.md (State)
        - .planning/config.json (Config, if exists)
        - ./CLAUDE.md (Project instructions, if exists)
        - .agents/skills/ (Project skills, if exists)
        </files_to_read>

        <task_focus>
        {If spawning for specific task: "Execute only task {TASK_NUM}, not the entire plan"}
        {If spawning for entire plan: "Execute all tasks in the plan"}
        </task_focus>
      "
    )
    ```

    Important: Keep the existing validation logic (lines 106-176) but apply it to each specialist in the SPECIALISTS array.
  </action>
  <verify>grep -A 20 'subagent_type="${CURRENT_SPECIALIST' get-shit-done/workflows/execute-phase.md</verify>
  <done>Task() calls use CURRENT_SPECIALIST variable with proper context injection via files_to_read</done>
</task>

<task type="auto">
  <name>Task 3: Add logging and status reporting</name>
  <files>get-shit-done/workflows/execute-phase.md</files>
  <action>
    Add clear logging to show which specialist is handling each task:

    1. Log when parsing specialist assignments from plan
    2. Log which specialist is being spawned for each task/plan
    3. Include specialist info in wave execution status

    Add logging statements:
    ```bash
    # After parsing specialists
    echo "Parsed ${#SPECIALISTS[@]} specialist assignments from plan"

    # Before spawning
    echo "Spawning ${CURRENT_SPECIALIST} for ${TASK_DESCRIPTION}..."

    # In wave description
    **Specialists:** ${UNIQUE_SPECIALISTS_IN_WAVE}
    ```

    Update the wave execution output to show:
    ```
    ## Wave {N}

    **{Plan ID}: {Plan Name}**
    {Description}
    Specialists: gsd-executor (task 1), python-pro (task 2-3)

    Spawning agents...
    ```
  </action>
  <verify>grep "Spawning.*for" get-shit-done/workflows/execute-phase.md</verify>
  <done>Logging shows specialist assignments and spawning decisions clearly</done>
</task>

</tasks>

<verification>
1. Run a phase with mixed specialist assignments in PLAN.md
2. Verify orchestrator parses specialist fields correctly
3. Confirm Task() calls use correct subagent_type
4. Check that context is passed via files_to_read
</verification>

<success_criteria>
- [ ] Orchestrator extracts specialist field from each task
- [ ] Task() spawning uses parsed specialist via subagent_type
- [ ] Context injection uses files_to_read pattern
- [ ] Logging clearly shows which specialist handles each task
</success_criteria>

<output>
After completion, create `.planning/phases/08-escape-hatch-protocol/08-01-SUMMARY.md`
</output>