---
phase: 01-foundation-detection-routing
plan: 03
type: execute
wave: 2
depends_on: [01-01, 01-02]
files_modified: [agents/gsd-executor.md]
autonomous: true
must_haves:
  truths:
    - "gsd-executor checks if specialists are available before delegation"
    - "Routing decision follows complexity and availability criteria"
    - "System falls back gracefully when specialists unavailable"
  artifacts:
    - path: "agents/gsd-executor.md"
      provides: "Availability checking and routing logic"
      contains: "check_specialist_availability"
    - path: "agents/gsd-executor.md"
      provides: "Adapter functions for task translation"
      contains: "<adapter_functions>"
  key_links:
    - from: "execute_tasks section"
      to: "specialist delegation"
      via: "routing decision logic"
      pattern: "ROUTE.*delegate|direct"
---

<objective>
Implement specialist availability checking, routing decisions, and adapter functions for task delegation.

Purpose: Enable gsd-executor to make intelligent routing decisions and translate between GSD task format and specialist prompts.
Output: Complete delegation flow with availability checks, routing logic, and adapter functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-detection-routing/01-RESEARCH.md

# Prior plan outputs
@.planning/phases/01-foundation-detection-routing/01-01-SUMMARY.md
@.planning/phases/01-foundation-detection-routing/01-02-SUMMARY.md

# Executor to modify
@agents/gsd-executor.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add availability checking logic</name>
  <files>agents/gsd-executor.md</files>
  <action>
Add specialist availability checking in the `<domain_detection>` section:

1. Create `check_specialist_availability()` function:
   ```bash
   check_specialist_availability() {
     local specialist="$1"

     # Primary check: Claude's agent directory
     if [ -f ~/.claude/agents/${specialist}.md ]; then
       echo "available"
       return 0
     fi

     # Secondary check: gsd agents directory (for testing)
     if [ -f ./agents/${specialist}.md ]; then
       echo "available"
       return 0
     fi

     # Log why unavailable for debugging
     echo "unavailable - ${specialist} not found in ~/.claude/agents/ or ./agents/"
     return 1
   }
   ```

2. Add routing decision logic that combines:
   - Domain detection result
   - Availability check
   - Complexity threshold
   - Feature flag status

3. Create `make_routing_decision()` function:
   ```bash
   make_routing_decision() {
     local task_desc="$1"
     local file_count="$2"

     # Check feature flag first
     if [ "$USE_SPECIALISTS" = "false" ]; then
       echo "direct - specialists disabled"
       return
     fi

     # Detect specialist for domain
     local specialist=$(detect_specialist_for_task "$task_desc")

     if [ -z "$specialist" ]; then
       echo "direct - no domain match"
       return
     fi

     # Check availability
     if ! check_specialist_availability "$specialist" >/dev/null; then
       echo "direct - $specialist unavailable"
       return
     fi

     # Check complexity threshold
     if [ "$file_count" -lt "$MIN_FILES" ]; then
       echo "direct - below complexity threshold"
       return
     fi

     echo "delegate - $specialist"
   }
   ```

Based on research: Filesystem check is instant and reliable. Fallback ensures system works when VoltAgent not installed.
  </action>
  <verify>grep -n "check_specialist_availability" agents/gsd-executor.md && grep -n "make_routing_decision" agents/gsd-executor.md</verify>
  <done>Availability checking and routing decision functions exist</done>
</task>

<task type="auto">
  <name>Task 2: Implement adapter functions</name>
  <files>agents/gsd-executor.md</files>
  <action>
Add a new `<adapter_functions>` section after `<domain_detection>`:

1. Create `gsd_task_adapter()` function to translate GSD tasks to specialist prompts:
   ```xml
   <adapter_functions>

   ## gsd-task-adapter
   Translates GSD task context into specialist-friendly prompt.

   gsd_task_adapter() {
     local task_name="$1"
     local task_action="$2"
     local task_verify="$3"
     local task_done="$4"
     local plan_objective="$5"
     local completed_tasks="$6"

     cat <<EOF
   <objective>
   $task_action

   This is task: $task_name
   Part of: $plan_objective
   </objective>

   <project_context>
   Read: ./CLAUDE.md (if exists), .agents/skills/ (if exists)
   Follow all project conventions and patterns.
   </project_context>

   <built_so_far>
   $completed_tasks
   </built_so_far>

   <verification>
   Task complete when:
   $task_verify

   Acceptance criteria:
   $task_done
   </verification>

   <constraints>
   - Make atomic commits for each logical change
   - Test your changes before marking complete
   - Report any deviations (bugs fixed, missing functionality added)
   - Follow security best practices
   - Handle errors gracefully
   </constraints>

   <output_format>
   When complete, provide:
   - Files modified: [list of paths]
   - Verification results: [what was tested and passed]
   - Deviations: [any changes beyond original scope]
   - Commit message: [suggested message for this work]
   </output_format>
   EOF
   }

   ## gsd-result-adapter
   Parses specialist output back to GSD format.

   gsd_result_adapter() {
     local specialist_output="$1"

     # Extract files modified (multiple patterns for robustness)
     local files_modified=$(echo "$specialist_output" | grep -A5 "Files modified:" | grep -E "^[-*]" | sed 's/^[-*] //')
     if [ -z "$files_modified" ]; then
       files_modified=$(echo "$specialist_output" | grep -oE "[a-zA-Z0-9_/-]+\.(ts|js|py|go|rs|md|json|yaml|yml)" | sort -u)
     fi

     # Extract verification results
     local verification=$(echo "$specialist_output" | grep -A10 "Verification results:" | tail -n +2)

     # Extract deviations
     local deviations=$(echo "$specialist_output" | grep -A10 "Deviations:" | tail -n +2)
     if [ -z "$deviations" ]; then
       deviations="None reported"
     fi

     # Extract commit message
     local commit_msg=$(echo "$specialist_output" | grep -A2 "Commit message:" | tail -n +2 | head -n 1)
     if [ -z "$commit_msg" ]; then
       commit_msg="Complete task via specialist"
     fi

     # Return structured format
     echo "FILES_MODIFIED: $files_modified"
     echo "VERIFICATION: $verification"
     echo "DEVIATIONS: $deviations"
     echo "COMMIT_MSG: $commit_msg"
   }
   </adapter_functions>
   ```

2. Add error handling for when specialist output doesn't match expected format.

3. Include fallback heuristics when structured output parsing fails.

Based on research: Robust parsing with fallbacks handles varied specialist output formats. Inline functions keep gsd-executor self-contained.
  </action>
  <verify>grep -n "<adapter_functions>" agents/gsd-executor.md && grep -n "gsd_task_adapter" agents/gsd-executor.md</verify>
  <done>Adapter functions translate between GSD and specialist formats</done>
</task>

<task type="auto">
  <name>Task 3: Integrate routing into execute_tasks flow</name>
  <files>agents/gsd-executor.md</files>
  <action>
Modify the `<step name="execute_tasks">` section to integrate delegation:

1. At the start of each task execution, add routing decision:
   ```bash
   # For auto tasks, determine execution route
   if [ "$task_type" = "auto" ]; then
     # Count files mentioned in task
     FILE_COUNT=$(echo "$task_action" | grep -oE "[a-zA-Z0-9_/-]+\.(ts|js|py|go|rs|md|json|yaml|yml)" | wc -l)

     # Make routing decision
     ROUTE_DECISION=$(make_routing_decision "$task_action" "$FILE_COUNT")
     ROUTE=$(echo "$ROUTE_DECISION" | cut -d' ' -f1)
     SPECIALIST=$(echo "$ROUTE_DECISION" | cut -d' ' -f3)

     echo "Routing decision: $ROUTE_DECISION"
   fi
   ```

2. Add delegation branch when route is "delegate":
   ```bash
   if [ "$ROUTE" = "delegate" ]; then
     echo "Delegating to specialist: $SPECIALIST"

     # Prepare adapted prompt
     SPECIALIST_PROMPT=$(gsd_task_adapter "$task_name" "$task_action" "$task_verify" "$task_done" "$plan_objective" "$completed_summary")

     # Invoke specialist via Task tool (placeholder - actual implementation in Phase 3)
     echo "Would invoke: Task(subagent_type='$SPECIALIST', prompt='$SPECIALIST_PROMPT')"

     # For now, fall back to direct execution
     echo "Note: Task tool integration pending (Phase 3), executing directly"
     ROUTE="direct"
   fi
   ```

3. Keep existing direct execution path intact for:
   - When route is "direct"
   - When specialists disabled
   - As fallback when delegation unavailable

4. Add logging for observability:
   ```bash
   # Track delegation attempts for summary
   if [ "$ROUTE" = "delegate" ]; then
     DELEGATION_ATTEMPTS="$DELEGATION_ATTEMPTS\n- Task: $task_name, Specialist: $SPECIALIST"
   fi
   ```

This prepares the integration points while maintaining working execution. Full Task tool integration happens in Phase 3.
  </action>
  <verify>grep -n "ROUTE_DECISION" agents/gsd-executor.md && grep -n "Delegating to specialist" agents/gsd-executor.md</verify>
  <done>Routing logic integrated into execute_tasks flow with delegation preparation</done>
</task>

</tasks>

<verification>
- Availability checking verifies specialists exist before delegation
- Routing decision combines detection, availability, and complexity
- Adapter functions translate task formats
- Execute_tasks flow includes routing branch
- Fallback to direct execution when specialists unavailable
</verification>

<success_criteria>
- check_specialist_availability() returns "available" for existing specialists
- make_routing_decision() returns "delegate" when all criteria met
- make_routing_decision() returns "direct" when specialists disabled or unavailable
- Adapter functions produce valid specialist prompts
- System logs delegation attempts for observability
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-detection-routing/01-03-SUMMARY.md`
</output>