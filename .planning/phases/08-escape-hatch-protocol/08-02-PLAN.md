---
phase: 08-escape-hatch-protocol
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - get-shit-done/workflows/execute-phase.md
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Orchestrator falls back to gsd-executor when specialist is null"
    - "Orchestrator falls back to gsd-executor when specialist is unavailable"
    - "Orchestrator validates specialist availability before spawning"
  artifacts:
    - path: "get-shit-done/workflows/execute-phase.md"
      provides: "Three-tier fallback logic and validation"
      min_lines: 450
      exports: []
  key_links:
    - from: "execute-phase.md"
      to: "available_agents.md"
      via: "grep validation"
      pattern: "grep.*available_agents.md"
    - from: "execute-phase.md"
      to: "gsd-executor"
      via: "fallback assignment"
      pattern: "SPECIALIST.*gsd-executor"
---

<objective>
Implement three-tier fallback mechanisms and integrate with existing validation logic.

Purpose: Ensure robust specialist spawning with graceful fallback to gsd-executor when specialists are null, unavailable, or fail validation.
Output: Complete specialist spawning system with comprehensive fallback handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-escape-hatch-protocol/08-RESEARCH.md
@.planning/phases/08-escape-hatch-protocol/08-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement three-tier fallback logic</name>
  <files>get-shit-done/workflows/execute-phase.md</files>
  <action>
    Enhance the specialist validation logic to implement comprehensive three-tier fallback:

    1. Tier 1: Check for null or empty specialist → use gsd-executor
    2. Tier 2: Check for "null" string value → use gsd-executor
    3. Tier 3: Check availability in roster → fallback if not found

    Implementation for each specialist in SPECIALISTS array:
    ```bash
    # Three-tier fallback for each specialist
    validate_specialist() {
      local SPECIALIST="$1"
      local TASK_NUM="$2"

      # Tier 1: No specialist assigned (empty/unset)
      if [ -z "$SPECIALIST" ]; then
        echo "Task $TASK_NUM: No specialist assigned, using gsd-executor" >&2
        echo "gsd-executor"
        return
      fi

      # Tier 2: Explicit null assignment
      if [ "$SPECIALIST" = "null" ]; then
        echo "Task $TASK_NUM: Specialist is null, using gsd-executor" >&2
        echo "gsd-executor"
        return
      fi

      # Tier 3: Check availability in roster
      if [ ! -f .planning/available_agents.md ]; then
        echo "Warning: available_agents.md missing, falling back to gsd-executor" >&2
        echo "gsd-executor"
        return
      fi

      if ! grep -q "^- \*\*${SPECIALIST}\*\*:" .planning/available_agents.md; then
        echo "Warning: Specialist '${SPECIALIST}' not available, falling back to gsd-executor" >&2
        echo "gsd-executor"
        return
      fi

      # Specialist is valid and available
      echo "$SPECIALIST"
    }
    ```

    Apply this validation when processing each task's specialist assignment.
    Store validated specialists back in the SPECIALISTS array.
  </action>
  <verify>grep -A 20 "validate_specialist" get-shit-done/workflows/execute-phase.md</verify>
  <done>Three-tier fallback function exists and handles null, empty, and unavailable cases</done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation with spawning flow</name>
  <files>get-shit-done/workflows/execute-phase.md</files>
  <action>
    Wire the validation logic into the main execution flow:

    1. After parsing SPECIALISTS array, validate each entry
    2. Update array with validated values (fallbacks applied)
    3. Use validated specialist when spawning

    Integration pattern:
    ```bash
    # After parsing specialists from plan
    echo "Validating specialist assignments..."
    for i in "${!SPECIALISTS[@]}"; do
      ORIGINAL="${SPECIALISTS[$i]}"
      VALIDATED=$(validate_specialist "$ORIGINAL" "$i")
      SPECIALISTS[$i]="$VALIDATED"

      if [ "$ORIGINAL" != "$VALIDATED" ]; then
        echo "  Task $i: $ORIGINAL → $VALIDATED (fallback applied)"
      fi
    done

    # Count unique specialists for reporting
    UNIQUE_SPECIALISTS=$(printf '%s\n' "${SPECIALISTS[@]}" | sort -u | paste -sd, -)
    echo "Specialists for this plan: $UNIQUE_SPECIALISTS"
    ```

    Ensure the existing validation block (lines 115-127) is either removed or refactored to use the new validate_specialist function to avoid duplication.
  </action>
  <verify>grep -B 5 -A 10 "Validating specialist" get-shit-done/workflows/execute-phase.md</verify>
  <done>Validation is integrated into main flow with clear logging of fallback decisions</done>
</task>

<task type="auto">
  <name>Task 3: Add testing support and error handling</name>
  <files>get-shit-done/workflows/execute-phase.md</files>
  <action>
    Add comprehensive error handling and testing support:

    1. Handle malformed specialist fields gracefully
    2. Add debug mode logging for specialist decisions
    3. Implement recovery from specialist spawn failures

    Error handling additions:
    ```bash
    # Handle malformed specialist field
    if [[ "$SPECIALIST" =~ [^a-zA-Z0-9_-] ]]; then
      echo "Warning: Malformed specialist name '$SPECIALIST', using gsd-executor" >&2
      SPECIALIST="gsd-executor"
    fi

    # Debug logging (if DEBUG=true in environment)
    if [ "${DEBUG:-false}" = "true" ]; then
      echo "DEBUG: Task $TASK_NUM specialist decision:"
      echo "  Original: $ORIGINAL_SPECIALIST"
      echo "  Validated: $VALIDATED_SPECIALIST"
      echo "  Available in roster: $AVAILABLE"
    fi

    # Spawn failure recovery
    # After Task() call, check for classifyHandoffIfNeeded error
    # This is a known Claude Code bug that doesn't indicate actual failure
    # Spot-check actual outputs instead of relying on error message
    ```

    Add a comment block explaining the fallback behavior:
    ```markdown
    ## Specialist Fallback Logic

    The orchestrator applies a three-tier fallback when determining which specialist to spawn:

    1. **Null/Empty** → gsd-executor (no specialist assigned)
    2. **"null" string** → gsd-executor (explicit null assignment)
    3. **Unavailable** → gsd-executor (specialist not in roster)

    This ensures every task can execute even if the ideal specialist isn't available.
    ```
  </action>
  <verify>grep -A 5 "Specialist Fallback Logic" get-shit-done/workflows/execute-phase.md</verify>
  <done>Error handling, debug logging, and documentation are in place</done>
</task>

</tasks>

<verification>
1. Test with plan containing null specialist assignments
2. Test with plan containing unavailable specialist names
3. Test with plan containing valid specialist assignments
4. Verify fallback logging appears in all cases
5. Confirm gsd-executor is used for all fallback scenarios
</verification>

<success_criteria>
- [ ] Three-tier fallback logic implemented and tested
- [ ] Validation integrated with existing flow
- [ ] Clear logging shows fallback decisions
- [ ] Error handling for edge cases
- [ ] Documentation explains fallback behavior
</success_criteria>

<output>
After completion, create `.planning/phases/08-escape-hatch-protocol/08-02-SUMMARY.md`
</output>